stepc   = require "stepc"
outcome = require "outcome"
async   = require "async"
mkdirp  = require "mkdirp"
fs      = require "fs"
readline = require "readline"
path     = require "path"
traverse = require "traverse"

validate  = require "./validate"
connect   = require "./connect"
ObjectID = require("mongodb").ObjectID


_types = {
  ObjectID: ObjectID,
  Date: Date
}

###
###

module.exports = (options, next) ->

  o  = outcome.e(next)
  rl = readline.createInterface(process.stdin, process.stdout)
  
  stepc.async(

    # validate fields
    (() -> 
      validate(options, @)
    ),

    # connect to mongodb
    o.s(() ->   
      connect(options, @)
    ),

    #import the collections
    o.s((@db) ->
      @()
    ),

    # load the collection paths
    o.s(() ->
      fs.readdir options.path, @
    )

    #
    o.s((collectionFiles) ->

      collectionFiles = collectionFiles.filter((name) ->
        not /.DS_Store/.test name
      ).map (name) ->
        options.path + "/" + name

      importFixtures collectionFiles, @db, @
    ),

    #
    next
  )

###
###

importFixtures = (fixturePaths, db, next) ->

  o = outcome.e next

  stepc.async(
    (() ->
      loadFixtures fixturePaths, @
    ),
    o.s((@items) ->
      removeReferences db, items, @
    ),
    o.s(() ->
      insertItems db, @items, @
    ),
    next
  )


loadFixtures = (fixturePaths, next) ->
  
  items = []

  async.eachSeries fixturePaths, ((fixturePath, next) ->
    items = items.concat require(fixturePath)
    next()
  ), outcome.e(next).s () ->
    next null, items.map (item) ->
      # fix the object type
      traverse(item).forEach (x) ->
        if x and x.__type
          this.update(new _types[x.__type](x.value))
      item


removeReferences = (db, items, next) ->
  async.eachSeries items, (item, next) ->

    refs = []

    for collection of item.__refs
      keys = item.__refs[collection]
      refs.push keys.map((key) -> { collection: collection, field: key })...

    async.eachSeries refs, ((ref, next) ->
      search = {}

      # object id might be a string, or object id instance
      search[ref.field] = item._id
      console.log("remove %s:%s.%s", ref.collection, item._id, ref.field);
      db.collection(ref.collection).remove(search, next)
    ), next
  , next



###
###

insertItems = (db, items, next) ->

  async.eachSeries items, ((item, next) ->

    collection = item.__collection

    # delete what's been generated by the export fn
    delete item.__collection
    delete item.__refs

    return next() if /^system/.test collection


    console.log("insert %s:%s", collection, item._id)
    db.collection(collection).insert(item, (err) ->
      if err
        console.warn err
      next()
    )
  ), next

  (fixturePath, next) ->
    collectionName = path.basename(fixturePath).split(".").shift()
    console.log "importing %s", collectionName

    results = require(fixturePath)
    importItems results, db, next

